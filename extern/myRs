
template <typename T>
GaloisField<T>::GaloisField(int fieldPower) : fieldPower(fieldPower),
                                              characteristic((static_cast<T>(1) << fieldPower) - 1),
                                              primitivePoly(FindPrimePolys<T>(fieldPower, 1)[0]) {
    powTable = new T[characteristic];
    logTable = new T[characteristic];

    T x = 1;
    for (int i = 0; i < characteristic - 1; i++) {
        powTable[i] = x;
        logTable[x] = i;
        x = x << 1;
        if (x & characteristic)
            x ^= primitivePoly;
    }

    powTable[characteristic - 1] = 1; // Alpha^255 = Alpha^0 = 1
    logTable[0] = 0;                   // Log(Alpha^0) is undefined
}

template <typename T>
GaloisField<T>::~GaloisField() {
    delete[] powTable;
    delete[] logTable;
}

template <typename T>
T GaloisField<T>::multNoLUT(T a, T b) {
    T result = 0;
    for (int i = 0; i < fieldPower; i++) {
        if ((b & 1) != 0)
            result ^= a;
        bool carry = (a & (static_cast<T>(1) << (fieldPower - 1))) != 0;
        a <<= 1;
        if (carry)
            a ^= primitivePoly;
        b >>= 1;
    }
    return result;
}

template <typename T>
T GaloisField<T>::mult(T a, T b) {
    if (a == 0 || b == 0)
        return 0;
    return powTable[(logTable[a] + logTable[b]) % (characteristic - 1)];
}

template <typename T>
T GaloisField<T>::div(T a, T b) {
    if (a == 0)
        return 0;
    if (b == 0)
        throw std::domain_error("GaloisField division by zero");
    return powTable[(logTable[a] + characteristic - 1 - logTable[b]) % (characteristic - 1)];
}

template <typename T>
T GaloisField<T>::pow(T x, T power) {
    if (x == 0)
        return (power == 0) ? 1 : 0;
    return powTable[(logTable[x] * power) % (characteristic - 1)];
}

template <typename T>
T GaloisField<T>::inv(T x) {
    if (x == 0)
        throw std::domain_error("GaloisField inversion of zero");
    return powTable[characteristic - 1 - logTable[x]];
}

template <typename T>
T GaloisField<T>::sqrt(T x) {
    if (x == 0)
        return 0;
    T root = (1 << ((fieldPower - 1) / 2));
    T result = 1;
    while (root) {
        T temp = result ^ root;
        result >>= 1;
        if (mult(temp, temp) == x)
            result |= root;
        root >>= 1;
    }
    return result;
}

// poly.cpp

template <typename T>
Poly<T> Poly_Create(int n, const T* coef) {
    Poly<T> poly;
    poly.resize(n + 1);
    std::copy(coef, coef + n + 1, poly.begin());
    return poly;
}

template <typename T>
void Poly_Add(Poly<T>& out, const Poly<T>& a, const Poly<T>& b) {
    size_t size = std::max(a.size(), b.size());
    out.resize(size);
    std::fill(out.begin(), out.end(), 0);
    for (size_t i = 0; i < a.size(); i++)
        out[i] ^= a[i];
    for (size_t i = 0; i < b.size(); i++)
        out[i] ^= b[i];
}

template <typename T>
void Poly_Scale(Poly<T>& out, const Poly<T>& in, T scale, const GaloisField<T>& gf) {
    size_t size = in.size();
    out.resize(size);
    for (size_t i = 0; i < size; i++)
        out[i] = gf.mult(in[i], scale);
}

template <typename T>
void Poly_Mult(Poly<T>& out, const Poly<T>& a, const Poly<T>& b, const GaloisField<T>& gf) {
    size_t size = a.size() + b.size() - 1;
    out.resize(size);
    std::fill(out.begin(), out.end(), 0);
    for (size_t i = 0; i < a.size(); i++)
        for (size_t j = 0; j < b.size(); j++)
            out[i + j] ^= gf.mult(a[i], b[j]);
}

template <typename T>
void Poly_Div(Poly<T>& result, Poly<T>& quotient, Poly<T>& remainder, const Poly<T>& a, const Poly<T>& b, const GaloisField<T>& gf) {
    if (b.size() == 0)
        throw std::domain_error("Polynomial division by zero");

    int degA = a.size() - 1;
    int degB = b.size() - 1;
    result.resize(0);
    quotient.resize(0);
    remainder.resize(a);

    while (degA >= degB) {
        int degDiff = degA - degB;
        T coef = gf.div(remainder[degA], b[degB]);
        quotient.push_back(coef);

        Poly<T> term = Poly_Create(degDiff, &gf.mult(coef, b[0]));
        Poly_Scale(term, term, coef, gf);

        Poly<T> temp;
        Poly_Mult(temp, b, term, gf);
        Poly_Add(remainder, remainder, temp);

        result.push_back(coef);
        degA = remainder.size() - 1;
    }

    std::reverse(result.begin(), result.end());
}

template <typename T>
T Poly_Eval(const Poly<T>& poly, T x, const GaloisField<T>& gf) {
    T result = 0;
    for (int i = poly.size() - 1; i >= 0; i--) {
        result = gf.mult(result, x) ^ poly[i];
    }
    return result;
}

template <typename T>
void Poly_ChienSearch(std::vector<unsigned int>& out, const Poly<T>& poly, int max, const GaloisField<T>& gf) {
    int n = poly.size() - 1;
    out.clear();
    for (int i = 0; i < n; i++) {
        T alpha_i = gf.pow(2, n - 1 - i);
        if (Poly_Eval(poly, alpha_i, gf) == 0) {
            out.push_back(i);
            if (out.size() >= max)
                break;
        }
    }
}

template <typename T>
void Poly_Pad(Poly<T>& poly, int left, int right) {
    poly.insert(poly.begin(), left, 0);
    poly.insert(poly.end(), right, 0);
}

template <typename T>
void Poly_Trim(Poly<T>& poly, int left, int right) {
    int i = 0;
    while (i < left && !poly.empty() && poly.front() == 0) {
        poly.erase(poly.begin());
        i++;
    }
    i = 0;
    while (i < right && !poly.empty() && poly.back() == 0) {
        poly.pop_back();
        i++;
    }
}

template <typename T>
void Poly_Append(Poly<T>& out, const Poly<T>& a, const Poly<T>& b) {
    out = a;
    out.insert(out.end(), b.begin(), b.end());
}

template <typename T>
void Poly_Reverse(Poly<T>& out, const Poly<T>& in) {
    out = in;
    std::reverse(out.begin(), out.end());
}

// reedsolomon.cpp

template <typename T>
ReedSolomon<T>::ReedSolomon(int fieldPower) : gf(fieldPower) {}

template <typename T>
void ReedSolomon<T>::createGenerator(Poly<T>& out, int nsym) {
    out.resize(nsym + 1);
    out[0] = 1;
    for (int i = 1; i <= nsym; i++) {
        Poly<T> term = Poly_Create(2, gf.powTable);
        term[0] = gf.pow(2, i);
        term[1] = 1;
        Poly_Mult(out, out, term, gf);
    }
}

template <typename T>
void ReedSolomon<T>::encode(T* out, T* data, int k, int nsym) {
    Poly<T> genPoly;
    createGenerator(genPoly, nsym);

    Poly<T> dataPoly = Poly_Create(k - 1, data);
    Poly<T> remainder;
    Poly_Div(remainder, out, dataPoly, genPoly, gf);
}

template <typename T>
void ReedSolomon<T>::calcSyndromes(Poly<T>& out, const Poly<T>& msg, int nsym) {
    out.resize(nsym);
    for (int i = 0; i < nsym; i++) {
        T x = gf.pow(2, i);
        out[i] = Poly_Eval(msg, x, gf);
    }
}

template <typename T>
bool ReedSolomon<T>::checkSyndromes(const Poly<T>& synd) {
    for (size_t i = 0; i < synd.size(); i++) {
        if (synd[i] != 0)
            return false;
    }
    return true;
}

template <typename T>
bool ReedSolomon<T>::findErrorLocator(Poly<T>& out, const Poly<T>& synd, int nsym, const Poly<T>* eraseLoc, int eraseCount) {
    Poly<T> oldLoc;
    Poly<T> loc;
    Poly<T> sigma;
    Poly<T> omega;
    Poly<T> temp;

    // Initial assumption: error locator is the same as syndrome
    out = synd;

    for (int erasePos = 0; erasePos < eraseCount; erasePos++) {
        T erasure = eraseLoc[erasePos];
        T q = 1;

        // Compute Q(x) = (x - alpha^erasure) for erasure positions
        for (int i = 0; i < out.size(); i++) {
            T alpha_erasure = gf.pow(2, erasure * i);
            q = gf.multNoLUT(q, alpha_erasure ^ 1);
        }

        // Calculate the error locator polynomial
        Poly_Create(2, gf.powTable);
        loc.resize(2);
        Poly_Create(2, gf.powTable);
        temp.resize(2);
        Poly_Create(2, gf.powTable);
        sigma.resize(2);
        sigma[0] = 1;
        sigma[1] = 0;

        for (int i = 0; i < out.size(); i++) {
            T x = gf.pow(2, i);
            loc[0] = gf.pow(x, i);
            loc[1] = 1;

            Poly_Create(2, gf.powTable);
            temp.resize(2);
            Poly_Mult(temp, loc, sigma, gf);
            Poly_Scale(temp, temp, out[i], gf);

            Poly_Add(omega, out, temp);
            Poly_Mult(temp, loc, q, gf);
            Poly_Mult(temp, temp, oldLoc, gf);

            Poly_Div(loc, temp, loc, sigma, gf);

            Poly_Mult(temp, q, sigma, gf);
            Poly_Scale(temp, temp, out[i], gf);
            Poly_Add(omega, omega, temp);

            oldLoc = loc;
            sigma = omega;

            Poly_Trim(out, 0, out.size() - 1);
        }
    }

    if (out.size() - 1 > nsym) {
        return false; // Too many errors to correct
    }

    Poly_Trim(out, 0, out.size() - 1);

    return true;
}

template <typename T>
bool ReedSolomon<T>::findErrors(std::vector<unsigned int>& out, const Poly<T>& errLoc, int n) {
    unsigned int errCount = errLoc.size() - 1;
    if (errCount > n / 2) {
        return false; // Too many errors to correct
    }

    for (size_t i = 0; i < errLoc.size(); i++) {
        if (errLoc[i] != 0) {
            T x = gf.pow(2, gf.characteristic - 1 - i);
            out.push_back(static_cast<unsigned int>(x));
        }
    }

    return true;
}

template <typename T>
void ReedSolomon<T>::ForneyAlgorithm(Poly<T>& out, const Poly<T>& synd, const Poly<T>& errLoc, int nsym) {
    int errCount = errLoc.size() - 1;

    Poly<T> derr;
    derr.resize(nsym + 1);
    derr[0] = 1;

    Poly<T> q;
    q.resize(nsym + 1);

    for (int i = 1; i <= nsym; i++) {
        T x = gf.pow(2, i);
        Poly<T> xi_minus_roots;
        xi_minus_roots.push_back(1);
        for (int j = 0; j < errCount; j++) {
            Poly<T> temp;
            temp.push_back(x);
            Poly_Add(xi_minus_roots, xi_minus_roots, temp);
        }

        T y = Poly_Eval(synd, x, gf);
        T xi_inv = gf.inv(Poly_Eval(errLoc, gf.inv(x), gf));
        T factor = gf.mult(y, xi_inv);

        Poly_Scale(xi_minus_roots, xi_minus_roots, factor, gf);
        Poly_Add(derr, derr

